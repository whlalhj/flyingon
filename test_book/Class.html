<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title></title>
</head>
<body>

    <script type="text/javascript">

        //function Class() {

        //    var _value = 1;

        //    this.getValue = function () {

        //        return _value;
        //    };

        //    this.setValue = function (value) {

        //        _value = value;
        //    };
        //};

        //var result = {};
        //result.__proto__ = Class.prototype;
        //Class.call(result);
        //return result;


        //function Class() {

        //    this._value = 1;
        //};

        //Class.prototype.getValue = function () {

        //    return this._value;
        //};

        //Class.prototype.setValue = function (value) {

        //    this._value = value;
        //};

        //new Class().getValue();
        //alert(new Class().getValue == new Class().getValue);



        //function superClass() {

        //};

        //superClass.prototype.show = function () {

        //    alert("superClass");
        //};

        //function subClass() {

        //};

        //subClass.prototype = new superClass();

        //subClass.prototype.show = function () {

        //    alert("subClass");
        //};



        //new superClass().show(); //此处显示"superClass"
        //new subClass().show();   //此处显示"subClass"



        ///* Simple JavaScript Inheritance
        //* By John Resig http://ejohn.org/
        //* MIT Licensed.
        //*/
        //// Inspired by base2 and Prototype
        //(function () {

        //    var initializing = false, fnTest = /xyz/.test(function () { xyz; }) ? /\b_super\b/ : /.*/;

        //    // The base Class implementation (does nothing)
        //    this.Class = function () { };

        //    // Create a new Class that inherits from this class
        //    Class.extend = function (prop) {

        //        var _super = this.prototype;

        //        // Instantiate a base class (but only create the instance,
        //        // don't run the init constructor)
        //        initializing = true;
        //        var prototype = new this();
        //        initializing = false;

        //        // Copy the properties over onto the new prototype
        //        for (var name in prop)
        //        {
        //            // Check if we're overwriting an existing function
        //            prototype[name] = typeof prop[name] == "function" && typeof _super[name] == "function" && fnTest.test(prop[name]) ? (function (name, fn) {

        //                return function () {

        //                    var tmp = this._super;

        //                    // Add a new ._super() method that is the same method
        //                    // but on the super-class
        //                    this._super = _super[name];

        //                    // The method only need to be bound temporarily, so we
        //                    // remove it when we're done executing
        //                    var ret = fn.apply(this, arguments);
        //                    this._super = tmp;

        //                    return ret;
        //                };

        //            })(name, prop[name]) : prop[name];
        //        }

        //        // The dummy class constructor
        //        function Class() {

        //            // All construction is actually done in the init method
        //            if (!initializing && this.init)
        //                this.init.apply(this, arguments);
        //        }

        //        // Populate our constructed prototype object
        //        Class.prototype = prototype;

        //        // Enforce the constructor to be what we expect
        //        Class.prototype.constructor = Class;

        //        // And make this class extendable
        //        Class.extend = arguments.callee;

        //        return Class;
        //    };

        //})();



        //var Person = Class.extend({

        //    init: function (isDancing) {
        //        this.dancing = isDancing;
        //    },
        //    dance: function () {
        //        return this.dancing;
        //    }
        //});

        //var Ninja = Person.extend({

        //    init: function () {
        //        this._super(false);
        //    },
        //    dance: function () {
        //        // Call the inherited version of dance()
        //        return this._super();
        //    },
        //    swingSword: function () {
        //        return true;
        //    }
        //});

        //var p = new Person(true);
        //p.dance(); // => true

        //var n = new Ninja();
        //n.dance(); // => false
        //n.swingSword(); // => true

        //// Should all be true
        //p instanceof Person && p instanceof Class && n instanceof Ninja && n instanceof Person && n instanceof Class;


        ////创建立即执行的匿名函数
        //(function () {

        //    //设置一个变量来分辨是最终使用还是内部初始化子类原型时使用
        //    //如果是内部初始化子类原型时使用则不直接构造函数以减少运行不必要的代码
        //    var initializing = false;

        //    //先创建一个空类作为根类且作为全局变量记下来
        //    this.Class = function () { };

        //    //给根类实现扩展类的方法,这里的Class其实就是前面那句的this.Class的值,省略了this.而已
        //    Class.extend = function (prop) {

        //        //打上内部实例化标记
        //        initializing = true;
        //        //实例化父类作为子类的原型对象
        //        var prototype = new this();
        //        //重置内部实例化标记
        //        initializing = false;

        //        //把扩展对象的属性复制到子类的原型上
        //        for (var name in prop)
        //        {
        //            prototype[name] = prop[name];
        //        }

        //        //创建一个类的壳
        //        function Class() {

        //            //如果不在内部使用状态且有构造函数就执行构造函数
        //            if (!initializing && this.init)
        //            {
        //                this.init.apply(this, arguments);
        //            }
        //        }

        //        //把前面创建的原型对象绑定了Class这个壳上, Class也就有了父类及扩展的方法及属性了
        //        Class.prototype = prototype;

        //        //设置constructor属性以便于以后用此做类型判断
        //        Class.prototype.constructor = Class;

        //        //让新创建的类也支持类扩展(作为父类扩展其它子类)
        //        Class.extend = arguments.callee;

        //        //返回类
        //        return Class;
        //    };

        //})();



        //Class.extend({});



        ////创建立即执行的匿名函数
        //(function () {

        //    //设置一个变量来分辨是最终使用还是内部初始化子类原型时使用
        //    //如果是内部初始化子类原型时使用则不直接构造函数以减少运行不必要的代码
        //    var initializing = false;

        //    //先创建一个空类作为根类且作为全局变量记下来
        //    this.Class = function () { };

        //    //给根类实现扩展类的方法,这里的Class其实就是前面那句的this.Class的值,省略了this.而已
        //    Class.extend = function (fn) {  //参数改成fn: function

        //        //打上内部实例化标记
        //        initializing = true;
        //        //实例化父类作为子类的原型对象
        //        var prototype = new this();
        //        //重置内部实例化标记
        //        initializing = false;


        //        ////把扩展对象的属性复制到子类的原型上
        //        //for (var name in prop)
        //        //{
        //        //    prototype[name] = prop[name];
        //        //}

        //        //以原型执行扩展函数
        //        fn.call(prototype, this.prototype);


        //        //创建一个类的壳
        //        function Class() {

        //            //如果不在内部使用状态且有构造函数就执行构造函数
        //            if (!initializing && this.init)
        //            {
        //                this.init.apply(this, arguments);
        //            }
        //        }

        //        //把前面创建的原型对象绑定了Class这个壳上, Class也就有了父类及扩展的方法及属性了
        //        Class.prototype = prototype;

        //        //设置constructor属性以便于以后用此做类型判断
        //        Class.prototype.constructor = Class;

        //        //让新创建的类也支持 类扩展(作为父类扩展其它子类)
        //        Class.extend = arguments.callee;

        //        //返回类
        //        return Class;
        //    };

        //})();




        ////创建立即执行的匿名函数
        //(function () {

        //    //先创建一个空类作为根类且作为全局变量记下来
        //    this.Class = function () { };

        //    //给根类实现扩展类的方法,这里的Class其实就是前面那句的this.Class的值,省略了this.而已
        //    Class.extend = function (fn) {  //参数改成fn: function

        //        //以父类原型为基础创建新对象
        //        var prototype = Object.create(this.prototype);

        //        //以原型执行扩展函数
        //        fn.call(prototype, this.prototype);

        //        //创建一个类的壳
        //        function Class() {

        //            //如果有构造函数就执行构造函数
        //            if (this.init)
        //            {
        //                this.init.apply(this, arguments);
        //            }
        //        }

        //        //把前面创建的原型对象绑定了Class这个壳上, Class也就有了父类及扩展的方法及属性了
        //        Class.prototype = prototype;

        //        //设置constructor属性以便于以后用此做类型判断
        //        Class.prototype.constructor = Class;

        //        //让新创建的类也支持 类扩展(作为父类扩展其它子类)
        //        Class.extend = arguments.callee;

        //        //返回类
        //        return Class;
        //    };

        //})();


    

        //定义类的函数
        function defineClass(typeName, superClass, fn) {

            //第二个参数可以省略
            if (!fn)
            {
                fn = superClass;
                superClass = function () { };
            }

            //以父类原型为基础创建新对象
            var prototype = Object.create(superClass.prototype);

            //以原型执行扩展函数
            fn.call(prototype, Class, superClass.prototype);

            //创建一个类的壳
            function Class() {

                //如果有构造函数就执行构造函数
                if (Class.create)
                {
                    Class.create.apply(this, arguments);
                }
            }

            //注册类至当前空间(此处以后可以和名字空间配合)
            this[typeName] = Class;

            //把前面创建的原型对象绑定了Class这个壳上, Class也就有了父类及扩展的方法及属性了
            Class.prototype = prototype;

            //设置constructor属性以便于以后用此做类型判断
            Class.prototype.constructor = Class;

            //返回类
            return Class;

        };



        defineClass("Test", function (Class, base) {


            //这是构造函数
            Class.create = function () {

            };

            //这是类方法
            Class.fn = function () {

            };
            

            //这是类的私有变量(注: 不是对象的私有变量)
            var value;

            //这是私有方法
            function fn() {

            };


            this.field1 = 1;

            this.field2 = 2;

            this.method1 = function () {

            };

            this.method2 = function () {

            };

        });


        var obj = new Test();




    </script>

</body>
</html>
